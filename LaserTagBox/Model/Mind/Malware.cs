using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using LaserTagBox.Model.Items;
using LaserTagBox.Model.Shared;
using Mars.Common.Core.Random;
using Mars.Interfaces.Environments;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ServiceStack;

namespace LaserTagBox.Model.Mind;

public class Malware : AbstractPlayerMind
{
    private PlayerMindLayer _mindLayer;
    private Position _goal;
    private bool _isFleeing;
    private Role _role;

    public override void Init(PlayerMindLayer mindLayer)
    {
        _mindLayer = mindLayer;
        // returnValue hypothetical could be null, but in 3 Player Game will never be null
    }

    public override void Tick()
    {
        _isFleeing = false;
        maybeReload();
        List<EnemySnapshot> enemys = maybeShoot(); //maybe he is fleeing from now on
        if (!_isFleeing)
        {
            decideMove(enemys);
        }
        useUnusedPoints();
        TeamCommuniation.Instance.endTurn();

    }

    /**
     * Lädt nach wenn keine Schüsse mehr im Magazin.
     */
    private void maybeReload()
    {
        if(Body.RemainingShots == 0) Body.Reload3();
    }

    private void flee()
    {
        List<Position> ditchesPositions = Body.ExploreDitches1();
        Position closestditch;
        if(ditchesPositions != null && ditchesPositions.Count != 0)
        {
            closestditch = ditchesPositions.First();
            foreach (var pos in ditchesPositions)
            {
                if (Body.GetDistance(pos) < Body.GetDistance(closestditch))
                    closestditch = pos;
            }
            Body.GoTo(closestditch);
        }
        else
        {
            if (Body.ActionPoints >= 2)
            {
                List<FlagSnapshot> flags = Body.ExploreFlags2();
                foreach (var flag in flags)
                {
                    if (flag.Team.Equals(Body.Color))
                    {
                        Body.GoTo(flag.Position); 
                    }
                }
            }
            
        }
        Body.ChangeStance2(Stance.Lying);
    }

    private void shoot(Position target)
    {
        if(Body.ActionPoints >= 7)
            Body.ChangeStance2(Stance.Lying);
        Body.Tag5(target);
    }
    /*
     * 
     */
    private List<EnemySnapshot> maybeShoot() //TODO: anstatt als Parameter zurück zu geben, in Map Speichern
    {
        if (!TeamCommuniation.Instance._EnemiesScouted)
        {
            List<EnemySnapshot> enemyList = Body.ExploreEnemies1();
            if (!enemyList.IsEmpty())
            {
                TeamCommuniation.Instance._EnemyPositions.AddRange(enemyList);
                TeamCommuniation.Instance._EnemiesScouted = true;
            }
        }

        List<EnemySnapshot> finalenemyList = TeamCommuniation.Instance._EnemyPositions;
        List<FriendSnapshot> friendList = Body.ExploreTeam();
        if (!finalenemyList.IsEmpty())
        {
            if (finalenemyList.Count() > friendsCloseToMe())
            {
                flee();
                _isFleeing = true;
            }
            
            if (Body.ActionPoints >= 8)
            {
                //Nahesten Enemy erhalten
                Position closestEnemyPosition = getClosestEnemy(finalenemyList);
                
                //Erhalte näheste Barrel zu enemy. Null, wenn keine Barrel in Sichtweite
                List<Position> explosiveBarrelsList = Body.ExploreExplosiveBarrels1();
                Position closestBarrelToEnemy = getClosestBarrelToEnemy(explosiveBarrelsList, closestEnemyPosition);
            
                //wenn Gegner im Radius von 3 von Barrel ist, auf Barrel schießen. Außer ein Teampartner ist in der nähe der Barrel
                if (closestBarrelToEnemy != null && getDistance(closestEnemyPosition, closestBarrelToEnemy) < 4.0 && !isFriendNearABarrel(closestBarrelToEnemy))
                {
                    shoot(closestBarrelToEnemy);
                }
                else //einfach so auf gegner schießen. 
                {
                    shoot(closestEnemyPosition); //ist nicht null, weil oben geprüft
                }
                
            }
            else
            {
                //Nahesten Enemy erhalten
                Position closestEnemyPosition = getClosestEnemy(finalenemyList);
                shoot(closestEnemyPosition);
            }
        }

        return finalenemyList;
    }

    /// Determines and retrieves the position of the closest enemy from a given list of enemies.
    /// <param name="enemies">A list of enemies to evaluate for proximity.</param> <return>The position of the closest enemy, or null if the list is empty or null.</return>
    /// /
    private Position getClosestEnemy(List<EnemySnapshot> enemys)
    {
        if (enemys == null || enemys.Count == 0)
        {
            return null;
        }

        int closestEnemyDistance = int.MaxValue;
        Position closestEnemyPosition = new Position();
        foreach (EnemySnapshot enemy in enemys)
        {
            if (Body.GetDistance(enemy.Position) < closestEnemyDistance)
            {
                closestEnemyPosition = enemy.Position;
            }

        }

        return closestEnemyPosition;
    }

    /**
     * Überprüft ob ein ein Friend (jemand aus dem eigenen Team) in der Nähe der eigegebenen Barrel ist.
     * (Das wird genutzt um zu schauen ob man auf das Fass schießen kann, ohne dabei einen Teammate zu verletzen.
     * @param barrelPositon
     */
    private bool isFriendNearABarrel(Position barrelPosition)
    {
        List<FriendSnapshot> friendList = Body.ExploreTeam();

        foreach (FriendSnapshot friend in friendList)
        {
            if (getDistance(friend.Position, barrelPosition) < 4)
            {
                return true;
            }
        }

        return false;
    }
    
    /// Determines and returns the closest explosive barrel to a specified enemy position from a given list of barrels.
    /// <param name="explosiveBarrelsList">List of positions representing the explosive barrels in the environment.</param> <param name="closestEnemyPosition">The position of the target enemy to compare distances against.</param> <return>The position of the closest explosive barrel to the specified enemy.</return>
    /// /
    public Position getClosestBarrelToEnemy(List<Position> explosiveBarrelsList, Position closestEnemyPosition)
    {
        if (explosiveBarrelsList == null || explosiveBarrelsList.Count == 0 || closestEnemyPosition == null)
        {
            return null;
        }

        int shortestDistance = int.MaxValue;
        Position positionDerKürzestenDistanz = new Position();
        
        foreach (Position barrel in explosiveBarrelsList)
        {
            if (shortestDistance > Body.GetDistance(barrel))
            {
                shortestDistance = (int) getDistance(barrel, closestEnemyPosition);
                positionDerKürzestenDistanz = barrel;
            }
        }
        
        return positionDerKürzestenDistanz;
    }

    /// Methode zur Berechnung der Manhattan-Distanz
    private double getDistance(Position position1, Position position2)
    {
        return Math.Abs(position2.X - position1.X) + Math.Abs(position2.Y - position1.Y);
    }

    private void decideMove(List<EnemySnapshot> enemys) //TODO: anstatt als Parameter zu übergeben, durch Map Speichern
    {
        //die 2 Flaggen holen
        if (!TeamCommuniation.Instance._FlagsScouted)
        {
            List<FlagSnapshot> scoutedflags = Body.ExploreFlags2();
            if (scoutedflags.IsEmpty())
                return;
            TeamCommuniation.Instance._FlagSnapshots = scoutedflags;
        }

        List<FlagSnapshot> flags = TeamCommuniation.Instance._FlagSnapshots;
        FlagSnapshot ownFlag = flags.FirstOrDefault(f => f.Team == Body.Color);
        FlagSnapshot enemyFlag = flags.FirstOrDefault(f => f.Team != Body.Color);

        //Wir haben Gegnerflagge
        if (enemyFlag.PickedUp)
        {
            //Wenn ich der Flaggenträger bin
            if (Body.CarryingFlag)
            {
                Position home = Body.ExploreOwnFlagStand();
                if (enemys != null && !enemys.IsEmpty())
                {
                    if (Body.Stance != Stance.Standing && Body.ActionPoints >= 4)
                        Body.ChangeStance2(Stance.Standing);
                    Body.GoTo(home);
                    Body.ChangeStance2(Stance.Lying);
                }
                else
                {
                    Body.GoTo(home);
                }
            }
            else
            {
                //Wenn ich nicht der Flaggenträger bin, beschütze ich unseren Flaggenträger oder Verteidige unsere eigene Flagge
                if (!ownFlag.Position.Equals(Body.ExploreOwnFlagStand()))
                {
                    //Rollenaufteilung //Distanz Vergleich wer von uns beiden Verteidigern näher an eigener Flagge ist um die zu verteidigen
                    double distanceIchZuOwnFlag =
                        getDistance(ownFlag.Position, Body.Position); //Abstand ich - unser Flaggenträger
                    List<FriendSnapshot> team = Body.ExploreTeam();
                    FriendSnapshot otherMember = team.First();
                    foreach (FriendSnapshot member in team)
                    {
                        if (!member.Position.Equals(enemyFlag
                                .Position)) //um zu gucken ob der Teammember der ist, welcher nicht die Flagge trägt
                        {
                            otherMember = member;
                            break;
                        }
                    }

                    double distanceOtherZuOwnFlag =
                        getDistance(ownFlag.Position, otherMember.Position); //Abstand ich - unser Flaggenträger

                    if (distanceIchZuOwnFlag < distanceOtherZuOwnFlag)
                    {
                        if (Body.Stance != Stance.Standing) Body.ChangeStance2(Stance.Standing);
                        Body.GoTo(ownFlag.Position);
                    }
                    else
                    {
                        //ich bin näher an unserem Flaggenträger. Also bleibe ich bei ihm, auch wenn die eigene Flagge getragen wird
                        if (Body.Stance != Stance.Standing) Body.ChangeStance2(Stance.Standing);
                        Position nextToFlag = new Position(enemyFlag.Position.X + 1, enemyFlag.Position.Y);
                        Body.GoTo(nextToFlag);
                    }
                }
                else
                {
                    //es verteidigen beide unseren Flagenträger
                    if (Body.Stance != Stance.Standing) Body.ChangeStance2(Stance.Standing);
                    Position nextToFlag = new Position(enemyFlag.Position.X + 1, enemyFlag.Position.Y);
                    Body.GoTo(nextToFlag);
                }
            }
        }
        else
        {//Wir haben nicht Gegner Flagge
            if (!ownFlag.Position.Equals(Body.ExploreOwnFlagStand()))
            { //Die eigene Flagge ist nicht zuhause, also unterwegs am getragen werden oder am rumliegen
                List<FriendSnapshot> friends = Body.ExploreTeam();
                FriendSnapshot otherMember0 = friends[0];
                FriendSnapshot otherMember1 = friends[1];
                FriendSnapshot otherMember2 = friends[2] ;

                if (getDistance(Body.Position, enemyFlag.Position) <
                    getDistance(otherMember0.Position, enemyFlag.Position) &&
                    getDistance(Body.Position, enemyFlag.Position) <
                    getDistance(otherMember1.Position, enemyFlag.Position) &&
                    getDistance(Body.Position, enemyFlag.Position) <
                    getDistance(otherMember2.Position, enemyFlag.Position))
                {//ich bin am nahesten vom Team an EnemyFlag also gehe ich sie holen.
                    if (Body.Stance != Stance.Standing) Body.ChangeStance2(Stance.Standing);
                    Body.GoTo(enemyFlag.Position);
                }
                else
                { //alle anderen beschützen die eigene Flagge
                    if (Body.Stance != Stance.Standing) Body.ChangeStance2(Stance.Standing);
                    Body.GoTo(ownFlag.Position);
                }
            }
            else
            { //die eigene Flagge ist zuhause. Also einfach alle auf Gegner Flagge gehen
                if (Body.Stance != Stance.Standing) Body.ChangeStance2(Stance.Standing);
                Body.GoTo(enemyFlag.Position);
            }
        }


        /*
        //Wenn die EnemyFlag gerade von einem aus dem Team getragen wird, dann gehe auf die Position rechts von ihm.
        if (!Body.CarryingFlag && enemyFlag.PickedUp)
        {
            if (Body.Stance != Stance.Standing) Body.ChangeStance2(Stance.Standing);
            Position nextToFlag = new Position(enemyFlag.Position.X + 1, enemyFlag.Position.Y);
            Body.GoTo(nextToFlag);
        }
        */


    //Wenn die eigene Flagge gerade vom gegner getragen wird
    if (!ownFlag.Position.Equals(Body.ExploreOwnFlagStand()))
        {
            if (Body.Stance != Stance.Standing) Body.ChangeStance2(Stance.Standing); //TODO: hinuzgefügt ungleich den rules.txt
            if(nearestToFlag(enemyFlag.Position))     //(Body.GetDistance(enemyFlag.Position) <= 10)
            {
                Body.GoTo(enemyFlag.Position);
            }
            else
            {
                Body.GoTo(ownFlag.Position);
            }
        }
        else
        {
            if (Body.Stance != Stance.Standing && Body.ActionPoints >= 2)
                Body.ChangeStance2(Stance.Standing);
            Body.GoTo(enemyFlag.Position);
            if (Body.ActionPoints >= 2)
                Body.ChangeStance2(Stance.Lying);
        }

        
    }

    private bool nearestToFlag(Position enemyFlag)
    {
        List<FriendSnapshot> team = Body.ExploreTeam();
        foreach (FriendSnapshot friend in team)
        {
            if (getDistance(friend.Position, enemyFlag) <= getDistance(Body.Position, enemyFlag))
                return false;
        }

        return true;
    }

    /// Utilizes any remaining action points to perform tasks such as reloading and exploring the environment
    /// for hills, ditches, and barriers. Communicates the discovered positions to the team.
    /// /
    private void useUnusedPoints()
    {
        Body.Reload3();
        List<Position> hills = Body.ExploreHills1();
        List<Position> ditches = Body.ExploreDitches1();
        List<Position> barrels = Body.ExploreBarrels1();

        TeamCommuniation teamCom = TeamCommuniation.Instance;
        
        if (hills != null && !hills.IsEmpty())
        {
            foreach (var hillPosition in hills)
            {
                teamCom._HillPositions.Add(hillPosition); //TODO: Das hinzufügen so richtig?
            }
        }

        if (ditches != null && !ditches.IsEmpty())
        {
            foreach (var ditchPosition in ditches)
            {
                teamCom._DitchPositions.Add(ditchPosition); //TODO: Das hinzufügen so richtig?
            }
        }

        if (barrels != null && !barrels.IsEmpty())
        {
            foreach (var barrierPosition in barrels)
            {
                teamCom._BarrierPositions.Add(barrierPosition); //TODO: Das hinzufügen so richtig?
            }
        }

        
        
        

    }
    private int friendsCloseToMe()
    {
        List<FriendSnapshot> team = Body.ExploreTeam();
        int count = 0;
        foreach (FriendSnapshot friend in team)
        {
            if(getDistance(friend.Position, Body.Position) <= 3)
                count++;
        }
        return count;
    }

}



public sealed class TeamCommuniation
{
    
    private static readonly Lazy<TeamCommuniation> _instance =
        new Lazy<TeamCommuniation>(() => new TeamCommuniation());
    public static TeamCommuniation Instance => _instance.Value;

    private HashSet<Position> _waterPositions;
    private HashSet<Position> _barrierPositions;
    private HashSet<Position> _hillPositions;
    private HashSet<Position> _ditchPositions;
    private List<EnemySnapshot> _enemyPositions;
    private List<FlagSnapshot> _flagSnapshots;
    private Dictionary<Role, Boolean> _roles;
    private int _playersfinished;
    private Boolean _enemiesScouted;
    private Boolean _flagsScouted;
    
    
    private TeamCommuniation()
    {
        _waterPositions = new HashSet<Position>();
        _barrierPositions = new HashSet<Position>();
        _hillPositions = new HashSet<Position>();
        _ditchPositions = new HashSet<Position>();
        _enemyPositions = new List<EnemySnapshot>();
        _flagSnapshots = new List<FlagSnapshot>();
        _roles = new Dictionary<Role, Boolean>();
        _roles.Add(Role.Bodyguard,false);
        _roles.Add(Role.FlagCarrier,false);
        _roles.Add(Role.Protector,false);
        _playersfinished = 0;
        _enemiesScouted = false;
        _flagsScouted = false;

    }

    public HashSet<Position> _WaterPositions
    {
        get => _waterPositions;
        set => _waterPositions = value;
    }

    public HashSet<Position> _BarrierPositions
    {
        get => _barrierPositions;
        set => _barrierPositions = value;
    }

    public HashSet<Position> _HillPositions
    {
        get => _hillPositions;
        set => _hillPositions = value;
    }

    public HashSet<Position> _DitchPositions
    {
        get => _ditchPositions;
        set => _ditchPositions = value;
    }

    public List<EnemySnapshot> _EnemyPositions
    {
        get => _enemyPositions;
        set => _enemyPositions = value;
    }

    public List<FlagSnapshot> _FlagSnapshots
    {
        get => _flagSnapshots;
        set => _flagSnapshots = value;
    }

    public Boolean _EnemiesScouted
    {
        get => _enemiesScouted;
        set => _enemiesScouted = value;
    }

    public Boolean _FlagsScouted
    {
        get => _flagsScouted;
        set => _flagsScouted = value;
    }

    public Boolean claimRole(Role role)
    {
        if (_roles[role])
            return false;
        else
        {
            _roles[role] = true;
            return true;
        }
    }

    public void endTurn()
    {
        _playersfinished++;
        if (_playersfinished == 3)
        {
            _playersfinished = 0;
            _enemyPositions.Clear();
            _enemiesScouted = false;
        }
            
    }
    
}

public enum Role
{
    Bodyguard,
    FlagCarrier,
    Protector
}